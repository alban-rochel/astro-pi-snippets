from image_processing import *

from orbit import ISS
from skyfield.api import load
from time import sleep

from datetime import datetime,timedelta
from pathlib import Path
import json
import math

from logzero import logger, logfile

# ASAP, this is the reference startup time, so that we don't get interrupted after 3 hours
start_time = datetime.now()
logfile("events.log", maxBytes=10000000)
logger.info("Starting at " + start_time.strftime("%Y/%m/%d %H:%M:%S"))

# Init: file naming
base_folder = Path(__file__).parent.resolve()

def climate_code_to_text(climate_zone):
    """
    Converts our climate zone codes into human-readable text.
    https://en.wikipedia.org/wiki/K%C3%B6ppen_climate_classification
    """
    # Rough classification, which is Precise_classification/10
    if climate_zone == 5:
        return "Tropical"
    elif climate_zone == 10:
        return "Dry"
    elif climate_zone == 15:
        return "Temperate"
    elif climate_zone == 20:
        return "Continental"
    # Precise classification
    elif climate_zone == 51:
        return "Tropical rainforest"
    elif climate_zone == 52:
        return "Tropical monsoon"
    elif climate_zone == 53:
        return "Savanna" # Tropical
    elif climate_zone == 101:
        return "Desert"
    elif climate_zone == 102:
        return "Semi arid" # Dry
    elif climate_zone == 151:
        return "Humid subtropical"
    elif climate_zone == 152:
        return "Oceanic"
    elif climate_zone == 153:
        return "Mediterranean" # Temperate
    elif climate_zone == 201:
        return "Humid continental"
    elif climate_zone == 202:
        return "Subarctic" # Continental
    else:
        return "Other"
    
def generate_save_name(base, timestamp, extension):
    """
    Generates a timestamped file name. The timestamp is such that sorting in alphabetic order is also the chronological order.
    """
    return f"{timestamp}_{base}.{extension}"

def generate_base_capture_metadata(time, position,climate_code):
    """
    Generates the base metadata attached to any capture.
    """
    data = {
        "time":
            {
            "year": time[0].strftime("%y"),
            "month": time[0].strftime("%m"),
            "day": time[0].strftime("%d"),
            "hour":time[0].strftime("%H"),
            "minute": time[0].strftime("%M"),
            "second": time[0].strftime("%S"),
            "micro": time[0].strftime("%f")
            },
        "coords":
            {
                "lat": position.latitude.degrees,
                "lon": position.longitude.degrees,
            },
        "climate":
            {
                "code": int(climate_code),
                "precise_zone": climate_code_to_text(climate_code),
                "rough_zone": climate_code_to_text(climate_code/10)
            }
        }
    return data

def compute_stats(ndvi_indexes):
    """
    With a dictionary of counts of points for each NDVI index as the entry ([0, 10]), computes mean and standard deviation of indexes.
    """
    total = 0
    mean = 0
    stdev = 0
    for index in range(11):
        total += ndvi_indexes[index]
        mean += index * ndvi_indexes[index]
    if total > 0:
        mean = mean / total
        for index in range(11):
            stdev += (mean - index) * (mean - index) * ndvi_indexes[index]
        stdev /= total
        stdev = math.sqrt(stdev)
    return (mean, stdev)
